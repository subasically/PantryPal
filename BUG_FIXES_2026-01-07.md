# Bug Fixes & Architectural Improvements - January 7, 2026

## üìã Session Summary

**Date:** January 7, 2026  
**Focus:** Multi-device sync debugging, household switching, checkout/grocery bugs  
**Bugs Fixed:** 9 critical bugs  
**Files Modified:** 12 files  
**Tests Completed:** Partial (interrupted by bugs)

---

## üêõ Bugs Fixed

### 1. **Inventory List Not Alphabetically Sorted**
**Symptom:** Items appeared in random order on iPhone, but correctly sorted on iPad  
**Root Cause:** `FetchDescriptor<SDInventoryItem>` was sorting by `expirationDate` instead of product name  
**Fix:** Changed sort descriptor to `SortDescriptor(\SDInventoryItem.product?.name)`  
**Files:** `ios/PantryPal/ViewModels/InventoryViewModel.swift` (line 29)  
**Impact:** All devices now show consistent alphabetical sorting

### 2. **UPC Lookup Failure - Missing householdId Parameter**
**Symptom:** Server 500 error when scanning barcodes: `ReferenceError: householdId is not defined`  
**Root Cause:** `lookupProductByUPC()` function signature missing `householdId` parameter, but function body referenced it for sync logging  
**Fix:** Added `householdId` parameter to function signature and route call  
**Files:** 
- `server/src/services/productService.js` (line 11)
- `server/src/routes/products.js` (line 18)  
**Impact:** Barcode scanning now works correctly

### 3. **Duplicate Grocery Items During Checkout**
**Symptom:** Checking out last item created TWO grocery entries: "Italian Seasoning" and "Good & Gather Italian Seasoning"  
**Root Cause:** Server auto-added full product name, but iOS also showed prompt and added again  
**Fix:** 
- **Phase 1:** Removed server-side auto-add logic (let iOS handle prompt)
- **Phase 2:** iOS checks `response.addedToGrocery` flag to skip duplicate prompt
- **Phase 3:** User requested prompt-only approach (no auto-add)  
**Files:**
- `server/src/routes/checkout.js` (lines 153-163 removed)
- `ios/PantryPal/Views/CheckoutView.swift` (lines 110-124)  
**Impact:** Only one grocery item created, only when user taps "Yes"

### 4. **Paywall Loading Spinner Disappearing Too Fast**
**Symptom:** On slower iPads, spinner would flash and disappear before purchase completed, making buttons re-enable during server verification  
**Root Cause:** `defer { isLoading = false }` executed immediately when `purchase()` returned, not when entire flow completed  
**Fix:** Removed `defer`, added manual `isLoading = false` calls after Thank You view shows (with 0.3s delay)  
**Files:** `ios/PantryPal/Views/PaywallView.swift` (lines 200-245)  
**Impact:** Loading state persists through entire purchase + verification flow

### 5. **Location Error After Joining Household**
**Symptom:** After joining household, got error: "Location not found or does not belong to this household"  
**Root Cause:** Local SwiftData cache retained old household's locations, but server validated against new household  
**Fix:** Added `clearLocalCache()` function to delete all SwiftData objects when joining household, then reset sync cursor  
**Files:** `ios/PantryPal/Views/HouseholdSetupView.swift` (lines 268-307)  
**Impact:** Clean slate when switching households, no orphaned data

### 6. **"Unknown Product" After Sync**
**Symptom:** Custom products added on one device showed as "Unknown Product" on other device after sync  
**Root Cause:** `applyProductChange()` in SyncService was a stub - only logged, never created/updated products during incremental sync  
**Fix:** Implemented full `applyProductChange()` logic to create/update/delete products from sync changes  
**Files:** `ios/PantryPal/Services/SyncService.swift` (lines 303-358)  
**Impact:** Products now sync correctly, inventory items display proper names

### 7. **Sync Cursor Race Condition**
**Symptom:** New devices would miss changes logged during their initial bootstrap sync  
**Root Cause:** Bootstrap set cursor to device's local time instead of server's time  
**Fix:** Changed bootstrap to call `syncChanges(since: "1970-01-01T00:00:00Z")` to get server timestamp  
**Files:** `ios/PantryPal/Services/SyncCoordinator.swift` (lines 88-96)  
**Impact:** Bootstrap uses server time, no missed changes

### 8. **Timestamp Format Mismatch in Sync**
**Symptom:** Incremental sync returned 0 changes despite new data in sync_log  
**Root Cause:** iOS sent ISO format (`2026-01-07T18:48:30Z`), SQLite stored format (`2026-01-07 18:48:30`), comparison failed  
**Fix:** Convert ISO to SQLite format before query: `since.replace('T', ' ').replace('Z', '')`  
**Files:** `server/src/routes/sync.js` (lines 23-27)  
**Impact:** Incremental sync now correctly filters changes

### 9. **Multiple logSync Parameter Order Bugs**
**Symptom:** Checkout deletes not syncing, random sync failures  
**Root Cause:** Function signature is `logSync(householdId, entityType, entityId, action, payload)` but 5 call sites had `entityId` and `action` swapped  
**Fix:** Systematic audit of all 16 logSync calls, fixed 5 bugs across 3 files  
**Files:**
- `server/src/routes/checkout.js` (lines 140, 145)
- `server/src/services/productService.js` (lines 205, 237)  
**Pattern:** Copy-paste error - developers reversed the last two parameters  
**Impact:** All sync logging now correct, comprehensive audit completed

---

## üîç Patterns & Root Causes

### Pattern 1: **Copy-Paste Parameter Order Bugs**
**Occurrences:** 5 instances of `logSync()` parameter order  
**Why it happened:** No type safety, similar parameter types (both strings)  
**Prevention:** TypeScript or named parameters

### Pattern 2: **Stub Functions Left Incomplete**
**Occurrences:** `applyProductChange()`, `applyGroceryChange()`  
**Why it happened:** Incremental development, forgot to implement  
**Prevention:** TODO comments, type-driven development

### Pattern 3: **Defer Gotchas in Async Functions**
**Occurrences:** PaywallView `defer { isLoading = false }`  
**Why it happened:** Misunderstanding of `defer` timing in async/await  
**Prevention:** Explicit state management, no `defer` in async functions

### Pattern 4: **Missing Cache Invalidation**
**Occurrences:** Household switching didn't clear SwiftData  
**Why it happened:** Assumed server would handle, didn't consider client state  
**Prevention:** Explicit state management on context switches

---

## üèóÔ∏è Architectural Improvements

### Backend (Node.js/Express/SQLite)

#### **1. Add TypeScript (HIGH PRIORITY)**
**Current Issue:** JavaScript allows parameter order bugs, missing properties, type confusion  
**Recommendation:**
```typescript
// Define explicit types
type SyncLogParams = {
  householdId: string;
  entityType: 'inventory' | 'product' | 'grocery' | 'location';
  entityId: string;
  action: 'create' | 'update' | 'delete';
  payload: Record<string, any>;
};

function logSync(params: SyncLogParams): void {
  // Implementation uses named parameters, can't get order wrong
}

// Call site:
logSync({
  householdId,
  entityType: 'inventory',
  entityId: item.id,
  action: 'delete',
  payload: {}
});
```
**Benefits:**
- Compile-time parameter order checking
- Auto-completion in IDE
- Refactoring safety
- Self-documenting code

**Migration Path:**
1. Add TypeScript to `package.json`
2. Rename `.js` ‚Üí `.ts` incrementally (start with models, utils)
3. Add types for external APIs (StoreKit validation, UPC lookup)
4. Enable strict mode after initial migration

#### **2. Implement Integration Tests for Sync**
**Current Issue:** Sync bugs discovered manually during multi-device testing  
**Recommendation:**
```javascript
// tests/sync.test.js
describe('Multi-Device Sync', () => {
  it('should sync product creation to other devices', async () => {
    // Device 1: Create custom product
    const product = await request(app)
      .post('/products')
      .set('Authorization', `Bearer ${user1Token}`)
      .send({ name: 'Test Product', brand: 'Test Brand' });

    // Device 2: Fetch changes
    const changes = await request(app)
      .get('/sync/changes?since=1970-01-01T00:00:00Z')
      .set('Authorization', `Bearer ${user2Token}`);

    expect(changes.body.changes).toContainEqual(
      expect.objectContaining({
        entityType: 'product',
        entityId: product.body.id,
        action: 'create'
      })
    );
  });

  it('should handle timestamp format conversion', () => {
    const isoTimestamp = '2026-01-07T18:48:30Z';
    const sqliteTimestamp = convertToSQLiteFormat(isoTimestamp);
    expect(sqliteTimestamp).toBe('2026-01-07 18:48:30');
  });
});
```

#### **3. Add Schema Validation Middleware**
**Current Issue:** Location errors caught at runtime, not at API boundary  
**Recommendation:**
```javascript
// middleware/validation.js
const { z } = require('zod');

const inventoryItemSchema = z.object({
  productId: z.string().uuid(),
  locationId: z.string().uuid(),
  quantity: z.number().int().positive(),
  expirationDate: z.string().datetime().optional(),
  notes: z.string().max(500).optional()
});

function validateInventoryItem(req, res, next) {
  try {
    inventoryItemSchema.parse(req.body);
    next();
  } catch (error) {
    res.status(400).json({ error: 'Invalid request', details: error.errors });
  }
}

// routes/inventory.js
router.post('/', authenticateToken, validateInventoryItem, async (req, res) => {
  // Handler only runs if validation passed
});
```

#### **4. Add Database Constraints**
**Current Issue:** Orphaned data possible (items referencing deleted locations)  
**Recommendation:**
```sql
-- db/schema.sql improvements
ALTER TABLE inventory
ADD CONSTRAINT fk_location
FOREIGN KEY (location_id) REFERENCES locations(id)
ON DELETE SET NULL; -- or CASCADE depending on desired behavior

ALTER TABLE inventory
ADD CONSTRAINT fk_product
FOREIGN KEY (product_id) REFERENCES products(id)
ON DELETE CASCADE; -- Delete inventory if product deleted

-- Add check constraints
ALTER TABLE inventory
ADD CONSTRAINT chk_quantity CHECK (quantity >= 0);
```

#### **5. Centralized Timestamp Handling**
**Current Issue:** ISO vs SQLite format conversions scattered  
**Recommendation:**
```javascript
// utils/timestamp.js
class TimestampUtil {
  static toISO(sqliteTimestamp) {
    return sqliteTimestamp.replace(' ', 'T') + 'Z';
  }

  static toSQLite(isoTimestamp) {
    return isoTimestamp.replace('T', ' ').replace('Z', '').replace(/\.\d+$/, '');
  }

  static now() {
    return new Date().toISOString().replace('T', ' ').replace('Z', '').replace(/\.\d+$/, '');
  }
}

// Use everywhere:
const now = TimestampUtil.now();
db.prepare('INSERT ... VALUES (?, ?)').run(id, now);
```

---

### iOS App (Swift 6/SwiftUI/SwiftData)

#### **6. Type-Safe Sync Models**
**Current Issue:** Sync payloads use `[String: Any]` dictionaries, prone to typos  
**Recommendation:**
```swift
// Models/SyncModels.swift
struct SyncInventoryPayload: Codable {
    let productId: String
    let quantity: Int
    let expirationDate: String?
    let notes: String?
    let locationId: String?
}

struct SyncProductPayload: Codable {
    let upc: String?
    let name: String
    let brand: String?
    let description: String?
    let image_url: String?
    let category: String?
    let is_custom: Bool
    let household_id: String?
}

// In SyncService:
private func applyProductChange(_ change: SyncChange, modelContext: ModelContext) throws {
    let payload = try JSONDecoder().decode(SyncProductPayload.self, from: change.payloadData)
    // Now we have type-safe access: payload.name, payload.brand, etc.
}
```

#### **7. Implement Sync Health Monitoring**
**Current Issue:** Sync failures are silent, hard to debug  
**Recommendation:**
```swift
@MainActor
class SyncHealthMonitor: ObservableObject {
    @Published var lastSyncStatus: SyncStatus = .idle
    @Published var failureCount: Int = 0
    @Published var lastError: String?
    
    enum SyncStatus {
        case idle
        case syncing
        case success(itemCount: Int)
        case failure(error: String)
    }
    
    func recordSuccess(itemCount: Int) {
        lastSyncStatus = .success(itemCount: itemCount)
        failureCount = 0
        lastError = nil
    }
    
    func recordFailure(error: Error) {
        lastSyncStatus = .failure(error: error.localizedDescription)
        failureCount += 1
        lastError = error.localizedDescription
        
        // Alert user if multiple failures
        if failureCount >= 3 {
            NotificationCenter.default.post(name: .syncHealthDegraded, object: nil)
        }
    }
}

// In Settings ‚Üí Debug:
Section("Sync Health") {
    LabeledContent("Status", value: monitor.lastSyncStatus.description)
    LabeledContent("Failures", value: "\(monitor.failureCount)")
    if let error = monitor.lastError {
        Text(error).font(.caption).foregroundColor(.red)
    }
}
```

#### **8. Add Unit Tests for Sync Logic**
**Current Issue:** Sync bugs only found during manual testing  
**Recommendation:**
```swift
// PantryPalTests/SyncServiceTests.swift
import XCTest
@testable import PantryPal

class SyncServiceTests: XCTestCase {
    func testApplyProductChange_Create() async throws {
        let modelContext = createTestModelContext()
        let change = SyncChange(
            id: "1",
            entityType: "product",
            entityId: "prod-123",
            action: "create",
            payload: [
                "name": "Test Product",
                "brand": "Test Brand",
                "is_custom": true
            ]
        )
        
        try await SyncService.shared.applyProductChange(change, modelContext: modelContext)
        
        let descriptor = FetchDescriptor<SDProduct>(predicate: #Predicate { $0.id == "prod-123" })
        let products = try modelContext.fetch(descriptor)
        
        XCTAssertEqual(products.count, 1)
        XCTAssertEqual(products.first?.name, "Test Product")
        XCTAssertEqual(products.first?.brand, "Test Brand")
    }
    
    func testTimestampConversion() {
        let isoTimestamp = "2026-01-07T18:48:30Z"
        let converted = TimestampUtil.toSQLite(isoTimestamp)
        XCTAssertEqual(converted, "2026-01-07 18:48:30")
    }
}
```

#### **9. Refactor Cache Invalidation**
**Current Issue:** Cache clearing logic duplicated in Settings and HouseholdSetup  
**Recommendation:**
```swift
// Services/CacheManager.swift
@MainActor
class CacheManager {
    static func clearAllHouseholdData(modelContext: ModelContext) async throws {
        print("üóëÔ∏è [CacheManager] Clearing all household data...")
        
        // Delete all SwiftData entities
        let items = try modelContext.fetch(FetchDescriptor<SDInventoryItem>())
        items.forEach { modelContext.delete($0) }
        
        let groceryItems = try modelContext.fetch(FetchDescriptor<SDGroceryItem>())
        groceryItems.forEach { modelContext.delete($0) }
        
        let products = try modelContext.fetch(FetchDescriptor<SDProduct>())
        products.forEach { modelContext.delete($0) }
        
        let locations = try modelContext.fetch(FetchDescriptor<SDLocation>())
        locations.forEach { modelContext.delete($0) }
        
        let actions = try modelContext.fetch(FetchDescriptor<SDPendingAction>())
        actions.forEach { modelContext.delete($0) }
        
        try modelContext.save()
        
        // Clear sync cursor
        SyncCoordinator.shared.clearAllSyncState()
        
        // Post notification
        NotificationCenter.default.post(name: .householdDataDeleted, object: nil)
        
        print("‚úÖ [CacheManager] Cache cleared successfully")
    }
}

// Usage in HouseholdSetupView:
await CacheManager.clearAllHouseholdData(modelContext: modelContext)
```

#### **10. Add SwiftUI Previews with Mock Data**
**Current Issue:** Can't preview views in isolation during development  
**Recommendation:**
```swift
// Preview Content/PreviewData.swift
struct PreviewData {
    static let mockUser = User(
        id: "user-123",
        email: "preview@test.com",
        householdId: "household-123"
    )
    
    static let mockHousehold = Household(
        id: "household-123",
        name: "Preview Household",
        ownerId: "user-123",
        isPremium: true,
        premiumExpiresAt: "2026-12-31T23:59:59Z"
    )
    
    static let mockItems = [
        InventoryItem(id: "1", productName: "Apples", quantity: 5, locationName: "Fridge"),
        InventoryItem(id: "2", productName: "Bread", quantity: 1, locationName: "Pantry"),
        InventoryItem(id: "3", productName: "Milk", quantity: 2, locationName: "Fridge")
    ]
}

#Preview {
    let authViewModel = AuthViewModel()
    authViewModel.currentUser = PreviewData.mockUser
    authViewModel.currentHousehold = PreviewData.mockHousehold
    
    return InventoryListView()
        .environment(authViewModel)
        .modelContainer(for: [SDInventoryItem.self], inMemory: true)
}
```

---

## üöÄ Post-MVP Feature Recommendations

Based on TODO.md analysis, here are architectural changes that will make future features easier:

### **For Recipe Feature**
**Prepare Now:**
- Add `categories` table (grocery, inventory, recipes will all use)
- Add `tags` junction table architecture (reusable for items, recipes, etc.)
- Abstract search/filter logic into reusable `SearchableListView<T>`

### **For Nutrition/Analytics**
**Prepare Now:**
- Start tracking `created_at` and `updated_at` on ALL tables (already partial)
- Add `deleted_at` for soft deletes (enables "restore" and waste tracking)
- Create `audit_log` table for user actions (who added/removed what, when)

### **For Receipt Scanner (OCR)**
**Prepare Now:**
- Add `purchase_price` and `purchase_date` columns to inventory (nullable)
- Create `receipts` table for storing OCR metadata
- Add batch import endpoint: `POST /inventory/batch` accepting array of items

### **For Multi-Household Support**
**Prepare Now:**
- Add `user_households` junction table (many-to-many instead of one-to-many)
- Add `active_household_id` to users table (which household currently viewing)
- Modify auth middleware to include `activeHouseholdId` in token claims

---

## üìä Testing Recommendations

### **Add CI/CD Pipeline**
```yaml
# .github/workflows/test.yml
name: Test

on: [push, pull_request]

jobs:
  backend-tests:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      - uses: actions/setup-node@v2
        with:
          node-version: '20'
      - run: cd server && npm ci
      - run: cd server && npm test
      - run: cd server && npm run lint

  ios-build:
    runs-on: macos-latest
    steps:
      - uses: actions/checkout@v2
      - uses: maxim-lobanov/setup-xcode@v1
        with:
          xcode-version: '15.0'
      - run: cd ios && xcodebuild test -scheme PantryPal -destination 'platform=iOS Simulator,name=iPhone 15'
```

### **Add E2E Testing for Critical Flows**
**Tools:** Detox (React Native style but works with SwiftUI), or custom XCTest UI tests  
**Critical Flows to Test:**
1. New user onboarding ‚Üí Create household ‚Üí Add item ‚Üí Verify in database
2. Multi-device sync ‚Üí Device A adds item ‚Üí Device B pulls ‚Üí Item appears
3. Checkout flow ‚Üí Item quantity ‚Üí 0 ‚Üí Grocery prompt ‚Üí Add to grocery
4. Premium purchase ‚Üí Subscribe ‚Üí Verify expiration set ‚Üí Features unlocked

---

## üîí Security Improvements

### **1. Rate Limiting (Already Implemented)**
‚úÖ Good! Keep it.

### **2. Add Input Sanitization**
```javascript
const sanitizeHtml = require('sanitize-html');

function sanitizeInput(req, res, next) {
  if (req.body) {
    for (let key in req.body) {
      if (typeof req.body[key] === 'string') {
        req.body[key] = sanitizeHtml(req.body[key], {
          allowedTags: [],
          allowedAttributes: {}
        });
      }
    }
  }
  next();
}
```

### **3. Add SQL Injection Protection**
**Current:** Using prepared statements ‚úÖ  
**Recommendation:** Add query logging to detect attempted injections:
```javascript
db.on('trace', (sql) => {
  if (sql.includes('DROP') || sql.includes('--') || sql.includes('/*')) {
    logger.warn('Suspicious SQL detected', { sql });
  }
});
```

---

## üìà Monitoring & Observability

### **Add Application Performance Monitoring (APM)**
**Options:** Sentry, LogRocket, DataDog  
**What to Track:**
- API response times (P50, P95, P99)
- Sync duration and failure rates
- StoreKit transaction success rate
- Device-level errors (iOS crashes, Swift errors)

### **Add Analytics Events**
```swift
// Services/AnalyticsService.swift
enum AnalyticsEvent {
    case itemAdded(type: String)
    case itemCheckedOut
    case groceryItemAdded
    case syncCompleted(duration: TimeInterval, itemCount: Int)
    case premiumPurchased
    case householdJoined
}

// Track anonymously (no PII)
AnalyticsService.track(.syncCompleted(duration: 1.5, itemCount: 10))
```

---

## üìù Documentation Improvements

### **Add API Documentation**
**Tool:** Swagger/OpenAPI  
**Example:**
```yaml
# swagger.yml
/inventory:
  post:
    summary: Create inventory item
    parameters:
      - name: productId
        in: body
        required: true
        schema:
          type: string
          format: uuid
      - name: locationId
        in: body
        required: true
        schema:
          type: string
          format: uuid
    responses:
      201:
        description: Item created
      400:
        description: Invalid input
      403:
        description: Free tier limit reached
```

### **Add Architecture Decision Records (ADRs)**
```markdown
# ADR-001: Use SQLite for Database

Date: 2025-12-01
Status: Accepted

## Context
Need a database for single-server deployment with <10k users initially.

## Decision
Use SQLite with WAL mode instead of PostgreSQL.

## Consequences
+ Simple deployment (no separate DB server)
+ Fast for small-medium scale
- Will need to migrate to Postgres if we exceed 10k concurrent users
- No built-in replication (need to use Litestream or similar)
```

---

## üéØ Priority Summary

### **Do Immediately (Before TestFlight)**
1. ‚úÖ Fix all sync bugs (DONE)
2. Add comprehensive testing (1-2 days)
3. Add error monitoring/Sentry (1 day)
4. Write runbook for production issues (1 day)

### **Do Before App Store Launch**
1. Migrate to AWS (reliability, scaling) (1 week)
2. Add TypeScript to backend (2-3 weeks)
3. Implement E2E tests for critical flows (1 week)
4. Add APM/observability (3 days)

### **Do Post-MVP (After Revenue Validation)**
1. Refactor for multi-household support
2. Add comprehensive unit test coverage
3. Implement recipe/nutrition features
4. Add CI/CD pipeline

---

## üèÅ Conclusion

Today's debugging session revealed several **systemic issues** that would have been prevented by:
1. **Type safety** (TypeScript on backend, stricter Swift types)
2. **Better testing** (integration tests for sync, unit tests for core logic)
3. **Architectural patterns** (centralized cache management, typed sync payloads)

The **immediate priority** is stabilizing for TestFlight. The **medium-term priority** is adding guardrails to prevent regression bugs. The **long-term priority** is refactoring for scalability and maintainability.

**Estimated Timeline:**
- TestFlight ready: 3-5 days (testing + monitoring)
- App Store ready: 2-3 weeks (AWS migration + TypeScript + E2E tests)
- Post-MVP ready: 1-2 months (multi-household + full test coverage)

